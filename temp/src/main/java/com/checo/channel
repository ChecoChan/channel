import javax.xml.stream.*;
import javax.xml.stream.events.*;
import java.io.InputStream;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.List;

public class Pain008Splitter {

    /**
     * 主方法：按单个 DrctDbtTxInf 交易拆分 pain.008 文件
     */
    public static List<String> splitPain008(InputStream in)
            throws XMLStreamException {

        List<String> result = new ArrayList<>();
        XMLInputFactory factory = XMLInputFactory.newInstance();
        XMLEventReader reader = factory.createXMLEventReader(in);

        String documentStart = null;
        String documentEnd = null;
        String cstmrStart = null;
        String cstmrEnd = null;
        String grpHdrXml = null;
        String pmtInfHeaderXml = null;

        // PmtInf 尾部 EndElement 缓存
        EndElement pmtInfEndElement = null;
        EndElement cstmrEndElement = null;
        EndElement documentEndElement = null;

        while (reader.hasNext()) {
            XMLEvent e = reader.nextEvent();

            if (!e.isStartElement()) {
                continue;
            }

            String localName = e.asStartElement().getName().getLocalPart();

            switch (localName) {

                case "Document":
                    documentStart = writeSingleEvent(e);
                    break;

                case "CstmrDrctDbtInitn":
                    cstmrStart = writeSingleEvent(e);
                    break;

                case "GrpHdr":
                    grpHdrXml = readExactElement(reader, e.asStartElement());
                    break;

                case "PmtInf":
                    PmtInfContext pmtInfCtx =
                            readPmtInfHeader(reader, e.asStartElement());
                    pmtInfHeaderXml = pmtInfCtx.headerXml;
                    break;

                case "DrctDbtTxInf":
                    // 每次循环只读取一个交易
                    String txXml = readExactElement(reader, e.asStartElement());

                    // 获取 PmtInf 的尾部（</PmtInf>）但不消费后续交易
                    if (pmtInfEndElement == null) {
                        pmtInfEndElement = findEndElement(reader, "PmtInf");
                    }

                    // 获取 CstmrDrctDbtInitn 尾部（</CstmrDrctDbtInitn>）
                    if (cstmrEndElement == null) {
                        cstmrEndElement = findEndElement(reader, "CstmrDrctDbtInitn");
                    }

                    // 获取 Document 尾部
                    if (documentEndElement == null) {
                        documentEndElement = findEndElement(reader, "Document");
                    }

                    // 拼接完整 XML
                    String fullXml = documentStart +
                            cstmrStart +
                            grpHdrXml +
                            pmtInfHeaderXml +
                            txXml +
                            pmtInfEndElement.toString() +
                            cstmrEndElement.toString() +
                            documentEndElement.toString();

                    result.add(fullXml);
                    break;
            }
        }

        reader.close();
        return result;
    }

    /** PmtInf header 上下文 */
    private static class PmtInfContext {
        final String headerXml;

        PmtInfContext(String headerXml) {
            this.headerXml = headerXml;
        }
    }

    /** 写单个 start event 为字符串 */
    private static String writeSingleEvent(XMLEvent e)
            throws XMLStreamException {
        StringWriter sw = new StringWriter();
        XMLEventWriter writer =
                XMLOutputFactory.newInstance().createXMLEventWriter(sw);
        writer.add(e);
        writer.close();
        return sw.toString();
    }

    /** 精确读取完整元素（start 已消费） */
    private static String readExactElement(
            XMLEventReader reader,
            StartElement start) throws XMLStreamException {

        String target = start.getName().getLocalPart();
        StringWriter sw = new StringWriter();
        XMLEventWriter writer =
                XMLOutputFactory.newInstance().createXMLEventWriter(sw);

        writer.add(start);

        int depth = 1;
        while (reader.hasNext() && depth > 0) {
            XMLEvent e = reader.nextEvent();
            writer.add(e);

            if (e.isStartElement()
                    && target.equals(e.asStartElement().getName().getLocalPart())) {
                depth++;
            } else if (e.isEndElement()
                    && target.equals(e.asEndElement().getName().getLocalPart())) {
                depth--;
            }
        }

        writer.close();
        return sw.toString();
    }

    /** 读取 PmtInf header（直到遇到第一个 DrctDbtTxInf） */
    private static PmtInfContext readPmtInfHeader(
            XMLEventReader reader,
            StartElement pmtInfStart) throws XMLStreamException {

        StringWriter sw = new StringWriter();
        XMLEventWriter writer =
                XMLOutputFactory.newInstance().createXMLEventWriter(sw);

        writer.add(pmtInfStart);

        while (reader.hasNext()) {
            XMLEvent next = reader.peek();

            // 跳过空白
            if (next.isCharacters() && next.asCharacters().isWhiteSpace()) {
                writer.add(reader.nextEvent());
                continue;
            }

            // 碰到第一个交易，header 结束
            if (next.isStartElement()
                    && "DrctDbtTxInf".equals(next.asStartElement().getName().getLocalPart())) {
                break;
            }

            writer.add(reader.nextEvent());
        }

        writer.close();
        return new PmtInfContext(sw.toString());
    }

    /** 查找 EndElement（不消费中间其他元素，只消费目标 EndElement） */
    private static EndElement findEndElement(
            XMLEventReader reader,
            String elementName) throws XMLStreamException {

        int depth = 0;

        while (reader.hasNext()) {
            XMLEvent e = reader.peek();

            if (e.isStartElement()
                    && elementName.equals(e.asStartElement().getName().getLocalPart())) {
                depth++;
            }

            if (e.isEndElement()
                    && elementName.equals(e.asEndElement().getName().getLocalPart())) {
                if (depth == 0) {
                    // 找到正确的 EndElement，不消费 peek
                    return e.asEndElement();
                } else {
                    depth--;
                }
            }

            reader.nextEvent(); // 消费其他事件
        }

        throw new XMLStreamException(
                "End element </" + elementName + "> not found");
    }
}