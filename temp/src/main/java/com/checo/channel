import javax.xml.stream.*;
import javax.xml.stream.events.*;
import java.io.InputStream;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.List;

public class Pain008Splitter {

    /* =========================
     * 对外主入口
     * ========================= */
    public static List<String> splitPain008(InputStream in)
            throws XMLStreamException {

        List<String> result = new ArrayList<>();

        XMLInputFactory factory = XMLInputFactory.newInstance();
        XMLEventReader reader = factory.createXMLEventReader(in);

        String documentStart = null;
        String documentEnd = null;
        String cstmrStart = null;
        String cstmrEnd = null;
        String grpHdrXml = null;

        PmtInfContext pmtInfCtx = null;

        while (reader.hasNext()) {
            XMLEvent e = reader.nextEvent();

            if (!e.isStartElement()) {
                continue;
            }

            String localName =
                    e.asStartElement()
                     .getName()
                     .getLocalPart();

            switch (localName) {

                case "Document":
                    documentStart = writeSingleEvent(e);
                    documentEnd = null; // 稍后从流里读
                    break;

                case "CstmrDrctDbtInitn":
                    cstmrStart = writeSingleEvent(e);
                    cstmrEnd = null;
                    break;

                case "GrpHdr":
                    grpHdrXml =
                        readExactElement(reader, e.asStartElement());
                    break;

                case "PmtInf":
                    pmtInfCtx =
                        readPmtInfHeader(reader, e.asStartElement());
                    break;

                case "DrctDbtTxInf":
                    if (pmtInfCtx == null) {
                        throw new IllegalStateException(
                            "DrctDbtTxInf appears before PmtInf");
                    }

                    String txXml =
                        readExactElement(reader, e.asStartElement());

                    String pmtInfEndXml =
                        readUntilEnd(reader, "PmtInf");

                    String cstmrEndXml =
                        readUntilEnd(reader, "CstmrDrctDbtInitn");

                    String documentEndXml =
                        readUntilEnd(reader, "Document");

                    String fullXml =
                        documentStart +
                        cstmrStart +
                        grpHdrXml +
                        pmtInfCtx.headerXml +
                        txXml +
                        pmtInfEndXml +
                        cstmrEndXml +
                        documentEndXml;

                    result.add(fullXml);

                    // 重置，只保留 header 供下一个 tx 用
                    pmtInfCtx.resetForNextTx();
                    break;
            }
        }

        reader.close();
        return result;
    }

    /* =========================
     * PmtInf 上下文
     * ========================= */
    private static class PmtInfContext {
        final String headerXml;

        PmtInfContext(String headerXml) {
            this.headerXml = headerXml;
        }

        void resetForNextTx() {
            // 目前不需要状态清理，占位，便于以后扩展
        }
    }

    /* =========================
     * 工具方法
     * ========================= */

    /** 写单个 start event（不 hardcode） */
    private static String writeSingleEvent(XMLEvent e)
            throws XMLStreamException {

        StringWriter sw = new StringWriter();
        XMLEventWriter writer =
            XMLOutputFactory.newInstance()
                            .createXMLEventWriter(sw);
        writer.add(e);
        writer.close();
        return sw.toString();
    }

    /** 精确读取一个完整元素（start 已被消费） */
    private static String readExactElement(
            XMLEventReader reader,
            StartElement start) throws XMLStreamException {

        String target =
            start.getName().getLocalPart();

        StringWriter sw = new StringWriter();
        XMLEventWriter writer =
            XMLOutputFactory.newInstance()
                            .createXMLEventWriter(sw);

        writer.add(start);

        int depth = 1;

        while (reader.hasNext()) {
            XMLEvent e = reader.nextEvent();
            writer.add(e);

            if (e.isStartElement()
                && target.equals(
                    e.asStartElement()
                     .getName()
                     .getLocalPart())) {
                depth++;
            }

            if (e.isEndElement()
                && target.equals(
                    e.asEndElement()
                     .getName()
                     .getLocalPart())) {
                depth--;
                if (depth == 0) break;
            }
        }

        writer.close();
        return sw.toString();
    }

    /** 读取 PmtInf 的 header（直到第一个 DrctDbtTxInf 之前） */
    private static PmtInfContext readPmtInfHeader(
            XMLEventReader reader,
            StartElement pmtInfStart)
            throws XMLStreamException {

        StringWriter sw = new StringWriter();
        XMLEventWriter writer =
            XMLOutputFactory.newInstance()
                            .createXMLEventWriter(sw);

        writer.add(pmtInfStart);

        while (reader.hasNext()) {
            XMLEvent next = reader.peek();

            if (next.isCharacters()
                && next.asCharacters().isWhiteSpace()) {
                writer.add(reader.nextEvent());
                continue;
            }

            if (next.isStartElement()
                && "DrctDbtTxInf".equals(
                    next.asStartElement()
                        .getName()
                        .getLocalPart())) {
                break;
            }

            writer.add(reader.nextEvent());
        }

        writer.close();
        return new PmtInfContext(sw.toString());
    }

    /** 从当前位置一直读到指定 EndElement（包含） */
    private static String readUntilEnd(
            XMLEventReader reader,
            String elementName)
            throws XMLStreamException {

        StringWriter sw = new StringWriter();
        XMLEventWriter writer =
            XMLOutputFactory.newInstance()
                            .createXMLEventWriter(sw);

        while (reader.hasNext()) {
            XMLEvent e = reader.nextEvent();
            writer.add(e);

            if (e.isEndElement()
                && elementName.equals(
                    e.asEndElement()
                     .getName()
                     .getLocalPart())) {
                break;
            }
        }

        writer.close();
        return sw.toString();
    }
}